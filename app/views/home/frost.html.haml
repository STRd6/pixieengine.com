- @fullscreen = true

%style
  :sass
    @import util

    $bar_top: 20px
    $margin: 12px

    .viewport
      & > .canvas
        +bounds(642px, 482px)
        +box-sizing(border-box)

        background-color: white
        border: 1px solid black

      canvas
        left: 0
        position: absolute
        top: 0

    .editor
      & > .content
        +box-sizing(border-box)
        padding-top: $bar_top + $margin

      .actions
        left: 0
        position: absolute
        top: 0

.editor
  .content
    .actions
      %button.raise Raise
      %button.lower Lower
      %button.rotate Rotate
      %button.grow Grow
      %button.shrink Shrink
      %button.transparentize Transparentize
      %button.opacify Opacify
      %button.tween Tween
    .viewport
      .canvas
        %canvas.canvas(width=640 height=480)
        %canvas.ui(width=640 height=480)

:coffeescript
  Sprite = (image, sourceX, sourceY, width, height) ->
    sourceX ||= 0
    sourceY ||= 0
    width ||= image.width
    height ||= image.height

    draw: (canvas, x, y) ->
      canvas.drawImage(
        image,
        sourceX,
        sourceY,
        width,
        height,
        x,
        y,
        width,
        height
      )

    width: width
    height: height

  $("body").dropImageReader
    callback: (file, event) ->
      loadSprite(event.target.result)

  loadSprite = (url) ->
    img = new Image()

    img.onload = ->
      addObject Sprite(this)

    img.src = url

  loadSprite("http://localhost:3000/images/shadow_logo_small.png")

  DisplayObject = (I) ->
    $.reverseMerge I,
      alpha: 1
      transform: Matrix()

    self = Core(I).extend
      draw: (canvas) ->
        if I.sprite
          canvas.withTransform I.transform, (canvas) ->
            canvas.globalAlpha I.alpha
            I.sprite.draw(canvas, 0, 0)

      drawOutline: (canvas) ->
        canvas.withTransform I.transform, (canvas) ->
          canvas.strokeRect(0, 0, I.width, I.height)

      move: (delta) ->
        I.transform = Matrix.translation(delta.x, delta.y).concat(I.transform)

      opacify: (amount) ->
        I.alpha = (I.alpha + amount).clamp(0, 1)

      pointWithin: (point) ->
        p = I.transform.inverse().transformPoint(point)

        return (0 <= p.x <= I.width) && (0 <= p.y <= I.height)

      registrationPoint: ->
        Point(I.width/2, I.height/2)

      rotate: (angle) ->
        I.transform = I.transform.rotate(angle, self.registrationPoint())

      scale: (amount) ->
        I.transform = I.transform.scale(1 + amount, 1 + amount, self.registrationPoint())

      transparentize: (amount) ->
        I.alpha = (I.alpha - amount).clamp(0, 1)

    self.attrAccessor "transform"

    self

  objects = []

  addObject = (sprite) ->
    objects.push DisplayObject
      height: sprite.height
      sprite: sprite
      width: sprite.width

  clock = 0
  refreshCanvas = ->
    canvas.clear()
    objects.invoke "draw", canvas

    canvas.strokeColor "rgba(96, 0, 96, 0.75)"
    activeObject?.drawOutline(canvas)

    if tweenFn
      activeObject.I.transform = tweenFn((clock % 128) / 128)

    clock += 1

  uiElement = $("canvas.ui")
  ui = uiElement.powerCanvas()

  canvas = $("canvas.canvas").powerCanvas()

  eventToLocal = (event) ->
    offset = uiElement.offset()

    Point(
      event.pageX - offset.left,
      event.pageY - offset.top
    )

  activeObject = null
  tweenFn = null
  mousedown = false
  previousMousePosition = Point(0, 0)

  $(document).bind "mousemove", (e) ->
    local = eventToLocal(e)

    if activeObject
      if mousedown
        activeObject.move(local.subtract(previousMousePosition))

    previousMousePosition = local

  uiElement.bind "mousedown", (e) ->
    local = eventToLocal(e)

    activeObject = objects.select (object) ->
      object.pointWithin(local)
    .last()

    mousedown = true

  uiElement.bind "mouseup", (e) ->
    mousedown = false

    return

  setInterval refreshCanvas, 1000 / 24

  window.generateMatrixTweenFunction = (begin, end, easing="linear") ->
    interpolations = ["a", "b", "c", "d", "tx", "ty"].map (key) ->
      Easing[easing](begin[key], end[key])

    return (t) ->
      params = interpolations.map (interpolation) ->
        interpolation(t)

      Matrix.apply null, params

  $("button.raise").click ->
    if activeObject
      objects.remove(activeObject)
      objects.push(activeObject)

  $("button.lower").click ->
    if activeObject
      objects.remove(activeObject)
      objects.unshift(activeObject)

  $("button.rotate").click ->
    activeObject?.rotate(Math.TAU / 16)

  $("button.tween").click ->
    if activeObject
      tweenFn = generateMatrixTweenFunction(Matrix(), activeObject.I.transform, "sinusoidalInOut")

  $("button.transparentize").click ->
    activeObject?.transparentize(0.10)

  $("button.opacify").click ->
    activeObject?.opacify(0.10)

  $("button.grow").click ->
    activeObject?.scale(0.25)

  $("button.shrink").click ->
    activeObject?.scale(-0.2)

  window.Easing =
    sinusoidal: (begin, end) ->
      change = end - begin
      (t) -> begin + change * (1 - Math.cos(t * Math.TAU / 4))

    sinusoidalOut: (begin, end) ->
      change = end - begin
      (t) -> begin + change * (0 + Math.sin(t * Math.TAU / 4))

  polynomialEasings = ["linear", "quadratic", "cubic", "quartic", "quintic"]

  polynomialEasings.each (easing, i) ->
    exponent = i + 1
    sign = if exponent % 2 then 1 else -1

    Easing[easing] = (begin, end) ->
      change = (end - begin)
      (t) -> begin + change * Math.pow(t, exponent)

    Easing["\#{easing}Out"] = (begin, end) ->
      change = end - begin
      (t) -> begin + change * (1 + sign * Math.pow(t - 1, exponent))

  ["sinusoidal"].concat(polynomialEasings).each (easing) ->
    Easing["\#{easing}InOut"] = (begin, end) ->
      midpoint = (begin + end)/2
      easeIn = Easing[easing](begin, midpoint)
      easeOut = Easing["\#{easing}Out"](midpoint, end)

      (t) ->
        if t < 0.5
          easeIn(2 * t)
        else
          easeOut(2 * t - 1)
